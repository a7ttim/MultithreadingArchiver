///////////////////////////////////////////////////////////
//  Unzipper.cs
//  Implementation of the Class Unzipper
//  Generated by Enterprise Architect
//  Created on:      15-апр-2019 23:18:22
//  Original author: A7ttim
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.IO.Compression;
using System.Threading;
using System.Collections;
using System.Linq;
using System.Diagnostics;

namespace Multithreading
{
    /// <summary>
    /// Класс распаковки
    /// </summary>
    public class Unzipper : IArchiverMode
    {
        private ArchiverTaskPool _readTaskPool;
        private ArchiverTaskPool _compressTaskPool;
        // TODO: обернуть Hashtable в ArchiverTaskPool
        private Hashtable _writeTaskPool;
        private Int64 _readBlockSize;
        private Int64 _lastBlock = 0;
        private bool _await = false;
        private Int64 _batchCount;

        private IUnzipperTaskFactory _taskFactory;
        private int _cores;
        private int _maxTasks;

        /// <summary>
        /// Конструктор класса Распаковки
        /// </summary>
        /// <param name="factory">
        /// Фабрика для создания задач
        /// </param>
        /// <param name="readBlockSize">
        /// Размер блока для чтения и сжатия
        /// </param>
        /// <param name="cores">
        /// Количество доступных потоков для распаковки
        /// </param>
        /// <param name="maxTasks">
        /// Ограничение по количеству задач, чтобы избежать переполнения памяти
        /// </param>
        public Unzipper(IUnzipperTaskFactory factory, Int64 readBlockSize = 4096, int cores = 2, int maxTasks = 1000)
        {
            _taskFactory = factory;
            _readBlockSize = readBlockSize;
            _cores = cores;
            _maxTasks = maxTasks;
        }

        /// <summary>
        /// Запустить распаковку заданного файла и сохранить по указанному пути
        /// </summary>
        /// <param name="readFile">
        /// Дескриптор файла для чтения
        /// </param>
        /// <param name="writeFile">
        /// Дескриптор файла для записи
        /// </param>
        public bool ProcessFile(FileDescriptor readFile, FileDescriptor writeFile)
        {
            _readTaskPool = new ArchiverTaskPool();
            _compressTaskPool = new ArchiverTaskPool();
            _writeTaskPool = new Hashtable();

            // Флаг для потока записи, сигнализирующий, что процесс генерации задач не окончен
            _await = true;

            try
            {
                // Запуск потока чтения
                {
                    Thread thread = new Thread(ReadingThread);
                    thread.Start(readFile);
                }

                // Запустить потоки распаковки
                for (int i = 0; i < _cores; i++)
                {
                    if (i < _cores)
                    {
                        Thread thread = new Thread(DecompressingThread);
                        thread.Start();
                    }
                }

                // Запустить поток записи
                {
                    Thread thread = new Thread(WritingThread);
                    thread.Start(writeFile);
                }
            }
            catch (Exception exc)
            {
                Console.WriteLine("Can't process threads");
                return false;
            }

            // Ждать, пока не завершится последний кусок и обновлять прогресс

            do
            {
                //Console.Clear();
                // Здесь должно высылаться оповещение контроллеру, чтобы тот обновил на GUI прогресс бар (W.I.P.) :)
                Thread.Sleep(100);
            } while (_lastBlock < _batchCount);

                _await = false;
            return true;
        }

        /// <summary>
        /// Метод для потока чтения. Чтение и генерация задач сжатия происходит в 1 поток, что даёт максимальную нагрузку на диск
        /// </summary>
        /// <param name="obj">
        /// Дескриптор файла для чтения
        /// </param>
        private void ReadingThread(object obj)
        {
            try
            {
                FileDescriptor read_file = ((FileDescriptor)obj);
                using (FileStream _fileToBeDecompressed = read_file.GetDescription.OpenRead())
                {
                    Int64 _batchCount = 0;
                    // Читать блоки архива, пока не закончится файл
                    while (_fileToBeDecompressed.Position < _fileToBeDecompressed.Length)
                    {
                        // Чтение размеров блоков и самих блоков
                        byte[] lengthBuffer = new byte[8];
                        _fileToBeDecompressed.Read(lengthBuffer, 0, lengthBuffer.Length);
                        int blockLength = BitConverter.ToInt32(lengthBuffer, 4);
                        byte[] compressedData = new byte[blockLength];
                        lengthBuffer.CopyTo(compressedData, 0);

                        _fileToBeDecompressed.Read(compressedData, 8, blockLength - 8);

                        _compressTaskPool.AddTask(_taskFactory.CreateDecompressionTask(_batchCount++, compressedData));
                        // Защита от переполнения памяти
                        if (_compressTaskPool.TaskCount() > _maxTasks)
                        {
                            Thread.Sleep(100);
                        }
                    }
                }
            }
            catch (Exception exc)
            {
                Console.WriteLine("Error on file read thread");
                _await = false;
            }
        }

        /// <summary>
        /// Метод потока распаковки. Распаковка и генерация задач записи работает в том количестве потоков, сколько процессоров доступно системе, 
        /// давая распределённую нагрузку на все ядра процессора почти на 100% 
        /// </summary>
        private void DecompressingThread()
        {
            while (_await)
            {
                DecompressionTaskInfo taskInfo = _compressTaskPool.NextTask() as DecompressionTaskInfo;
                if (taskInfo == null)
                {
                    continue;
                }
                try
                {
                    byte[] buffer = taskInfo.GetData() as byte[];
                    using (MemoryStream memoryStream = new MemoryStream(buffer))
                    {
                        using (GZipStream compressStream = new GZipStream(memoryStream, CompressionMode.Decompress))
                        {
                            int size = BitConverter.ToInt32(buffer, buffer.Length - 4);
                            byte[] bytes = new byte[size];
                            compressStream.Read(bytes, 0, bytes.Length);
                            byte[] array = bytes.ToArray();
                            Hashtable.Synchronized(_writeTaskPool).Add(taskInfo.GetId(), _taskFactory.CreateDecompressionWriteTask(taskInfo.GetId(), array));
                        }
                    }
                    
                }
                catch (Exception exc)
                {
                    Console.WriteLine("Error on decompression thread:" + exc);
                    _await = false;
                }
                // Защита от переполнения памяти
                if (_writeTaskPool.Count > _maxTasks)
                {
                    Thread.Sleep(100);
                }
            }
        }


        /// <summary>
        /// Метод для потока записи. Запись происходит в один поток, так как требуется упорядочить сжатые блоки по Id
        /// </summary>
        /// <param name="obj">
        /// Дескриптор файла для записи
        /// </param>
        private void WritingThread(object obj)
        {
            FileDescriptor writeFile = ((FileDescriptor)obj);
            try
            {
                using (FileStream fileWrite = writeFile.GetDescription.OpenWrite())
                {
                    _lastBlock = 0;
                    Hashtable tasks = Hashtable.Synchronized(_writeTaskPool);
                    while (_await)
                    {
                        if (tasks.ContainsKey(_lastBlock))
                        {
                            DecompressionWriteTaskInfo taskInfo = tasks[_lastBlock] as DecompressionWriteTaskInfo;
                            taskInfo.Execute(fileWrite);
                            tasks.Remove(_lastBlock);
                            _lastBlock++;
                        }
                        else
                        {
                            continue;
                        }
                    }
                }
            }
            catch (Exception exc)
            {
                Console.WriteLine("Error on writing thread: " + exc);
                _await = false;
            }
        }
    }
}