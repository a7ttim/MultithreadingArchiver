///////////////////////////////////////////////////////////
//  Unzipper.cs
//  Implementation of the Class Unzipper
//  Generated by Enterprise Architect
//  Created on:      15-апр-2019 23:18:22
//  Original author: A7ttim
///////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Threading;

namespace Multithreading
{
    /// <summary>
    /// Класс распаковки
    /// </summary>
    public class Unzipper
    {
        private QueueTaskPool _readTaskPool;
        private QueueTaskPool _compressTaskPool;
        private HashtableTaskPool _writeTaskPool;
        private Int64 _fileLength;
        /// <summary> 
        /// Счётчик блоков для наблюдателя
        /// </summary>
        private Int64 _lastBlock = 0;
        /// <summary> 
        /// Счётчик считанных блоков, выставлена единица, 
        /// чтобы наблюдатель не прерывал процесс сразу
        /// </summary>
        private Int64 _batchCount = 1;
        private bool _await = false;

        private ITaskFactory _taskFactory;
        private int _cores;
        private int _maxTasks;

        /// <summary>
        /// Конструктор класса Распаковки
        /// </summary>
        /// <param name="factory">
        /// Фабрика для создания задач
        /// </param>
        /// <param name="cores">
        /// Количество доступных потоков для распаковки
        /// </param>
        /// <param name="maxTasks">
        /// Ограничение по количеству задач, чтобы избежать переполнения памяти
        /// </param>
        public Unzipper(ITaskFactory factory, int cores = 2, int maxTasks = 100)
        {
            _taskFactory = factory;
            _cores = cores;
            _maxTasks = maxTasks;
        }

        /// <summary>
        /// Запустить распаковку заданного файла и сохранить по указанному пути
        /// </summary>
        /// <param name="readFile">
        /// Дескриптор файла для чтения
        /// </param>
        /// <param name="writeFile">
        /// Дескриптор файла для записи
        /// </param>
        public bool ProcessFile(FileDescriptor readFile, FileDescriptor writeFile)
        {
            _readTaskPool = new QueueTaskPool();
            _compressTaskPool = new QueueTaskPool();
            _writeTaskPool = new HashtableTaskPool();

            _fileLength = readFile.GetDescription.Length;

            try
            {
                _await = true;
                // Запуск потока чтения
                {
                    new Thread(ReadingThread).Start(readFile);
                }
                // Запустить потоки распаковки
                for (int i = 0; i < _cores; i++)
                {
                    new Thread(DecompressingThread).Start();
                }
                // Запустить поток записи
                {
                    new Thread(WritingThread).Start(writeFile);
                }
            }
            catch (Exception exc)
            {
                Console.WriteLine("Can't process threads");
#if DEBUG
                Console.WriteLine(exc);
#endif
                return false;
            }

            // Ждать, пока не завершится последний кусок и обновлять прогресс
            do
            {
                Thread.Sleep(500);
            } while (_lastBlock < _batchCount);

            _await = false;
            return true;
        }

        /// <summary>
        /// Метод для потока чтения. Чтение и генерация задач сжатия происходит в 1 поток, что даёт максимальную нагрузку на диск
        /// </summary>
        /// <param name="obj">
        /// Дескриптор файла для чтения
        /// </param>
        private void ReadingThread(object obj)
        {
            FileDescriptor read_file = obj as FileDescriptor;
            try
            {
                using (FileStream _fileToBeDecompressed = read_file.GetDescription.OpenRead())
                {
                    _batchCount = 0;
                    // Читать блоки архива, пока не закончится файл
                    while (_fileToBeDecompressed.Position < _fileLength)
                    {                        
                        // Защита от переполнения памяти
                        if (_compressTaskPool.TaskCount() > _maxTasks * _cores)
                        {
                            continue;
                        }
                        ITaskInfo task = _taskFactory.CreateReadTask(_batchCount, 0);
                        _compressTaskPool.AddTask(_taskFactory.CreateProcessTask(_batchCount++, task.Execute(_fileToBeDecompressed) as byte[]));
                    }
                }
            }
            catch (Exception exc)
            {
                Console.WriteLine("Error on file reading");
                _await = false;
            }
        }

        /// <summary>
        /// Метод потока распаковки. Распаковка и генерация задач записи работает в том количестве потоков, сколько процессоров доступно системе, 
        /// давая распределённую нагрузку на все ядра процессора почти на 100% 
        /// </summary>
        private void DecompressingThread()
        {
            try
            {
                while (_await)
                {
                    // Защита от переполнения памяти
                    if (_writeTaskPool.TaskCount() > _maxTasks)
                    {
                        continue;
                    }
                    ITaskInfo taskInfo = _compressTaskPool.NextTask() as ITaskInfo;
                    if (taskInfo == null)
                    {
                        continue;
                    }
                    _writeTaskPool.AddTask(_taskFactory.CreateWriteTask(taskInfo.GetId(), taskInfo.Execute(null) as byte[]));
                }
            }
            catch (Exception exc)
            {
                Console.WriteLine("Error on file unpacking");
                _await = false;
            }
        }

        /// <summary>
        /// Метод для потока записи. Запись происходит в один поток, так как требуется упорядочить сжатые блоки по Id
        /// </summary>
        /// <param name="obj">
        /// Дескриптор файла для записи
        /// </param>
        private void WritingThread(object obj)
        {
            FileDescriptor writeFile = obj as FileDescriptor;
            try
            {
                using (FileStream fileWrite = writeFile.GetDescription.OpenWrite())
                {
                    _lastBlock = 0;
                    while (_await)
                    {
                        ITaskInfo taskInfo = _writeTaskPool.NextTask() as ITaskInfo;
                        if (taskInfo == null)
                        {
                            continue;
                        }
                        taskInfo.Execute(fileWrite);
                        _lastBlock++;
                    }
                }
            }
            catch (Exception exc)
            {
                Console.WriteLine("Error on file writing");
                _await = false;
            }
        }
    }
}