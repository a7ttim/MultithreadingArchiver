///////////////////////////////////////////////////////////
//  Compressor.cs
//  Implementation of the Class Compressor
//  Generated by Enterprise Architect
//  Created on:      15-апр-2019 23:18:22
//  Original author: A7ttim
///////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Threading;

namespace MultithreadingArchiver
{
    /// <summary>
    /// Класс сжатия
    /// </summary>
    class Compressor
    {
        /// <summary> 
        /// Хранилища для задач
        /// </summary>
        private IArchiverTaskPool _readTaskPool;
        private IArchiverTaskPool _compressTaskPool;
        private IArchiverTaskPool _writeTaskPool;
        /// <summary> 
        /// Флаг для потоков, сигнализирующий, что процесс генерации задач не окончен
        /// </summary>
        private Int64 _lastZippedBlock = 0;
        /// <summary> 
        /// Счётчик блоков для наблюдателя
        /// </summary>
        private Int64 _lastWritedBlock = 0;
        /// <summary> 
        /// Количество целых кусков
        /// </summary>
        private Int64 _batchCount;
        /// <summary> 
        /// Количество кусков
        /// </summary>
        private Int64 _totalCount;
        /// <summary> 
        /// Длина каждого куска
        /// </summary>
        private Int64 _readBlockSize;
        /// <summary> 
        /// Длина последнего куска
        /// </summary>
        private Int64 _lastPiece;
        /// <summary> 
        /// Фабрика для создания задач
        /// </summary>
        private ITaskFactory _taskFactory;
        /// <summary> 
        /// Количество доступных ядер
        /// </summary>
        private int _cores;
        /// <summary> 
        /// Максимальное число задач
        /// </summary>
        private int _maxTasks;
        /// <summary> 
        /// Время, на которое приостанавливается поток в мс
        /// Подобрано приближением
        /// </summary>
        private const int _sleep = 3;
        /// <summary> 
        /// Токен для остановки процесса
        /// </summary>
        CancellationToken _cancellationToken;

        /// <summary>
        /// Конструктор класса сжатия
        /// </summary>
        /// <param name="factory">
        /// Фабрика для создания задач
        /// </param>
        /// <param name="readBlockSize">
        /// Размер блока для чтения и сжатия
        /// </param>
        /// <param name="cores">
        /// Количество доступных потоков для сжатия
        /// </param>
        /// <param name="maxTasks">
        /// Ограничение по количеству задач, чтобы избежать переполнения памяти
        /// </param>
        public Compressor(CancellationToken cancellationToken, ITaskFactory factory, Int64 readBlockSize = 4096, int cores = 2, int maxTasks = 100)
        {
            _cancellationToken = cancellationToken;
            _taskFactory = factory;
            _readBlockSize = readBlockSize;
            // Если 3 ядра и меньше - один поток на сжатие, остальные два на чтение и запись файлов
            // Если 4 ядра и больше - 2 и более потока на сжатие, один на чтение и один на запись файлов
            _cores = cores > 3 ? cores - 2 : 1;
            _maxTasks = maxTasks;
        }

        /// <summary>
        /// Запустить сжатие заданного файла и сохранить по указанному пути
        /// </summary>
        /// <param name="readFile">
        /// Дескриптор файла для чтения
        /// </param>
        /// <param name="writeFile">
        /// Дескриптор файла для записи
        /// </param>
        public bool ProcessFile(FileDescriptor readFile, FileDescriptor writeFile)
        {
            _readTaskPool = new QueueTaskPool();
            _compressTaskPool = new QueueTaskPool();
            _writeTaskPool = new HashtableTaskPool();
            
            /// Длина исходного файла
            Int64 _fileLength = readFile.GetDescription.Length;
            // Количество целых кусков
            _batchCount = _fileLength / _readBlockSize;
            // Длина последнего куска
            _lastPiece = _fileLength % _readBlockSize;
            // Общее количество кусков с учётом последнего
            _totalCount = _batchCount;

            if(_lastPiece > 0)
            {
                _totalCount++;
            }

            try
            {
                // Запуск потока чтения
                Thread readingThread = new Thread(ReadingThread);
                readingThread.Start(readFile);

                // Запустить потоки распаковки
                for (int i = 0; i < _cores; ++i)
                {
                    Thread compressingThread = new Thread(CompressingThread);
                    compressingThread.Start();
                }

                // Запустить поток записи
                Thread writingThread = new Thread(WritingThread);
                writingThread.Start(writeFile);

                // Запуск потока генерации задач
                Thread generatorThread = new Thread(GeneratorThread);
                generatorThread.Start();

                // Наблюдатель - ждёт, пока не завершится последний кусок и обновляет прогресс
                while (_lastWritedBlock < _totalCount && !_cancellationToken.IsCancellationRequested)
                {
#if !DEBUG
                    Console.Clear();
#endif
                    Console.WriteLine("Press Ctrl+C for cancellation");
                    // Здесь должно высылаться оповещение контроллеру, чтобы тот обновил на GUI прогресс бар (W.I.P.) =]
                    Console.WriteLine("Progress: {0}%", Math.Truncate(_lastWritedBlock / (double)_totalCount * 100));
                    Thread.Sleep(500);
                }

                if (_cancellationToken.IsCancellationRequested)
                {
                    Console.WriteLine("Compression cancelled");
                    return false;
                }

#if !DEBUG
                Console.Clear();
#endif
                Console.WriteLine("Compression completed");
                return true;
            }
            catch (Exception exc)
            {
                Console.WriteLine("Can't process threads");
#if DEBUG
                Console.WriteLine(exc);
#endif
                return false;
            }
        }

        /// <summary>
        /// Метод для потока генерации задач для чтения. Необходим для более гибкого распределения нагрузки на поток чтения файла
        /// </summary>
        private void GeneratorThread()
        {
            try
            {
                int wait = Convert.ToInt32(Math.Pow(_cores, 1.5));
                for (int i = 0; i < _batchCount; ++i)
                {
                    // Защита от переполнения памяти
                    // Без этого произойдёт переполнение
                    // Нагенерируется больше задач, чем возможно обработать за промежуток времени, проверено на SSD
                    // TODO: Возможно подобрать более оптимальные значения maxTasks за счёт градиентного спуска
                    if (_readTaskPool.TaskCount() > _maxTasks)
                    {
                        --i;
                        Thread.Sleep(_sleep);
                        continue;
                    }
                    _readTaskPool.AddTask(_taskFactory.CreateReadTaskInfo(i, _readBlockSize));
                }
                // Обработка последнего куска
                if (_batchCount < _totalCount)
                {
                    _readTaskPool.AddTask(_taskFactory.CreateReadTaskInfo(_batchCount, _lastPiece));
                }
#if DEBUG
                Console.WriteLine("End of generating tasksInfos");
#endif
            }
            catch (Exception exc)
            {
                Console.WriteLine("Error on generating reading tasks");
#if DEBUG
                Console.WriteLine(exc);
#endif
            }
        }

        /// <summary>
        /// Метод для потока чтения. Чтение и генерация задач сжатия происходит в 1 поток, что даёт максимальную нагрузку на диск
        /// </summary>
        /// <param name="obj">
        /// Дескриптор файла для записи
        /// </param>
        private void ReadingThread(object obj)
        {
            FileDescriptor read_file = obj as FileDescriptor;
            try
            {
                using (FileStream _fileToBeCompressed = read_file.GetDescription.OpenRead())
                {
                    Int64 lastBlock = 0;
                    while (lastBlock < _totalCount && !_cancellationToken.IsCancellationRequested)
                    {
                        // Защита от переполнения памяти
                        if (_compressTaskPool.TaskCount() > _maxTasks * _cores)
                        {
                            Thread.Sleep(1);
                            continue;
                        }
                        ITaskInfo taskInfo = null;
                        taskInfo = _readTaskPool.NextTask();
                        if (taskInfo == null)
                        {
                            Thread.Sleep(_sleep);
                            continue;
                        }
                        _compressTaskPool.AddTask(_taskFactory.CreateProcessTaskInfo(lastBlock++, (taskInfo.Execute(_fileToBeCompressed) as byte[])));
                    }
#if DEBUG
                    Console.WriteLine("End of reading");
#endif
                }
            }
            catch (Exception exc)
            {
                Console.WriteLine("Error on file reading");
#if DEBUG
                Console.WriteLine(exc);
#endif
            }
        }

        /// <summary>
        /// Сжатие и генерация задач записи работает в том количестве потоков, сколько процессоров доступно системе, 
        /// давая распределённую и почти 100% нагрузку на все ядра процессора
        /// </summary>
        private void CompressingThread()
        {
            try
            {
                while (_lastZippedBlock < _totalCount && !_cancellationToken.IsCancellationRequested)
                {
                    // Защита от переполнения памяти
                    if (_writeTaskPool.TaskCount() > _maxTasks)
                    {
                        Thread.Sleep(_sleep);
                        continue;
                    }
                    ITaskInfo taskInfo = _compressTaskPool.NextTask();
                    if (taskInfo == null)
                    {
                        Thread.Sleep(_sleep);
                        continue;
                    }
                    _writeTaskPool.AddTask(_taskFactory.CreateWriteTaskInfo(taskInfo.GetId(), taskInfo.Execute(null) as byte[]));
                    _lastZippedBlock++;
                }
#if DEBUG
                Console.WriteLine("End of compressing");
#endif
            }
            catch (Exception exc)
            {
                Console.WriteLine("Error on file compressing");
#if DEBUG
                Console.WriteLine(exc);
#endif
            }
        }

        /// <summary>
        ///  Запись происходит в один поток, так как требуется упорядочить сжатые блоки по Id через Hashtable
        /// </summary>
        private void WritingThread(object obj)
        {
            FileDescriptor writeFileDescriptor = obj as FileDescriptor;
            try
            {
                using (FileStream writeFileStream = writeFileDescriptor.GetDescription.OpenWrite())
                {
                    while (_lastWritedBlock < _totalCount && !_cancellationToken.IsCancellationRequested)
                    {
                        ITaskInfo taskInfo = _writeTaskPool.NextTask() as ITaskInfo;
                        if (taskInfo == null)
                        {
                            Thread.Sleep(1);
                            continue;
                        }
                        taskInfo.Execute(writeFileStream);
                        _lastWritedBlock++;
                    }
                }
            }
            catch (Exception exc)
            {
                Console.WriteLine("Error on file writing");
#if DEBUG
                Console.WriteLine(exc);
#endif
            }
        }
    }
}